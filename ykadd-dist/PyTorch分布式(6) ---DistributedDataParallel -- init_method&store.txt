PyTorch分布式(6) ---DistributedDataParallel -- init_method&store

https://www.cnblogs.com/rossiXYZ/p/15553670.html

目录
[源码解析] PyTorch分布式(6) ---DistributedDataParallel -- init_method&store
0x00 摘要
0x01 回顾
1.1 基本概念
1.2 初始化进程组
0x02 初始化
2.1 初始化方法
2.2 init_method VS store
2.3 rendezvous
2.4 小结
0x03 Store
3.1 _rendezvous_handlers
3.2 handlers
3.2.1 _file_rendezvous_handler
3.2.2 _tcp_rendezvous_handler
3.2.3 _env_rendezvous_handler
3.3 使用
3.3.1 使用 handler
3.3.2 使用 Store
3.3.2.1 _new_process_group_helper
3.3.2.2 ProcessGroupGloo
3.4 小结
0x04 TCPStore
4.1 TCPStore in python
4.2 TCPStore in CPP
4.2.1 API接口
4.2.2 socket用处
4.2.2.1 业务分工
4.2.2.2 Set 例子
4.2.2.3 Set 和 watchKey 结合
4.2.3 功能函数
4.2.4 构建函数
4.2.5 TCPStoreWorkerDaemon
4.2.5.1 watchKey
4.2.5.2 运行
4.2.6 TCPStoreMasterDaemon
4.2.6.1 运行
4.2.6.2 调用业务
4.2.6.4 处理业务
添加
获取
watchKey
通知
4.2.7 总结
0x00 摘要
本文是 PyTorch 分布式系列的第六篇， 介绍 DistributedDataParallel 所依赖的初始化方法和Store这两个概念。

本系列其他文章如下：

深度学习利器之自动微分(1)

深度学习利器之自动微分(2)

[源码解析]深度学习利器之自动微分(3) --- 示例解读

[源码解析]PyTorch如何实现前向传播(1) --- 基础类(上)

[源码解析]PyTorch如何实现前向传播(2) --- 基础类(下)

[源码解析] PyTorch如何实现前向传播(3) --- 具体实现

[源码解析] Pytorch 如何实现后向传播 (1)---- 调用引擎

[源码解析] Pytorch 如何实现后向传播 (2)---- 引擎静态结构

[源码解析] Pytorch 如何实现后向传播 (3)---- 引擎动态逻辑

[源码解析] PyTorch 如何实现后向传播 (4)---- 具体算法

[源码解析] PyTorch 分布式(1)------历史和概述

[源码解析] PyTorch 分布式(2) ----- DataParallel(上)

[源码解析] PyTorch 分布式(3) ----- DataParallel(下)

[源码解析] PyTorch 分布式(4)------分布式应用基础概念

[源码解析] PyTorch分布式(5) ------ DistributedDataParallel 总述&如何使用

0x01 回顾
1.1 基本概念
关于分布式通信，PyTorch 提供的几个概念是：进程组，后端，初始化，Store。

    进程组 ：DDP是真正的分布式训练，可以使用多台机器来组成一次并行运算的任务。
            为了能够让 DDP 的各个worker之间通信，PyTorch 设置了进程组这个概念。

    后端 ：后端这个概念是一个逻辑上的概念。本质上后端是一种IPC通信机制。

    初始化 : 虽然有了后端和进程组的概念，但是如何让 worker 在建立进程组之前发现彼此？
            这就需要一种初始化方法来告诉大家传递一个信息：如何联系到其它机器上的进程。

    Store : 可以认为是分布式键值存储，
            利用这个存储就可以在组中的进程之间共享信息以及初始化分布式包 （通过显式创建存储来作为init_method的替代）。


....


0x02 初始化
2.1 初始化方法
目前DDP模块支持三种初始化方式：
    Environment variable initialization
    Shared file-system initialization：init_method='file:///mnt/nfs/sharedfile'
    TCP initialization ：init_method='tcp://10.1.1.20:23456'

环境变量
此方法将从环境变量中读取配置，是允许完全自定义获取信息的方式。通过在所有机器上设置以下四个环境变量，
所有进程都可以正常连接到master（就是 rank 0 进程）以获取其他进程的信息，并最终与它们握手。

    MASTER_PORT：rank 0 进程的机器上的端口。
    MASTER_ADDR：rank 0 进程的机器上的 IP 地址。
    WORLD_SIZE: 进程总数，因此master知道要等待多少worker。
    RANK: 每个进程的rank，所以进程会知道自己是否是master。

共享文件系统
共享文件系统要求所有进程都可以访问共享文件系统，并将通过共享文件协调它们。
这意味着每个进程都将打开文件，写入其信息，并等待每个进程都这样做。
之后，所有所需的信息都将可供所有流程使用。为了避免竞争条件，文件系统必须通过fcntl支持锁定 。

    dist.init_process_group(
        init_method='file:///mnt/nfs/sharedfile',
        rank=args.rank,
        world_size=4)

TCP
TCP 初始化方式是通过提供rank 0进程的IP和端口来实现的，
在这里，所有worker都可以连接到等级为 0 的进程并交换有关如何相互联系的信息。

    dist.init_process_group(
        init_method='tcp://10.1.1.20:23456',
        rank=args.rank,
        world_size=4)

....


2.2 init_method VS store
我们很好奇，为什么要有 init_method 和 store 这两个参数？
通过看 init_process_group 代码我们可以发现以下规律。

    当 MPI 时候， init_method 没有用处。

    在非 MPI 后端时候，如果没有 store 参数，则使用 init_method 构建一个store。

所以最终还是落到了 store 之上，store才是其作用的实体。
        if store is None:
            rendezvous_iterator = rendezvous(
                init_method, rank, world_size, timeout=timeout
            )
            store, rank, world_size = next(rendezvous_iterator)
            store.set_timeout(timeout)

...

3.4 小结
从目前分析结果来看，我们拓展结论如下：

    init_method 最终还是落到了 store 之上，store才是起作用的实体。
    参与的进程需要找到彼此并交换信息才能够进行通信。这个过程被称为rendezvous。
    rendezvous 其实就是返回了某一种store 以供后续通信使用。
    在进程组之中，会使用 store 来构建通信，等待，存取等。

我们接下来选择 TCPStore进行相信分析。


....


0x04 TCPStore
TCPStore 是基于 TCP 的分布式键值存储实现。
服务器存储/保存数据，而存储客户端可以通过 TCP 连接到服务器存储并执行诸如set()插入键值对、get()检索键值对等操作。
系统中应该有一个初始化完毕的TCPStore存储服务器，因为存储客户端将等待这个存储服务以建立连接。

TCPStore 的参数如下：

    host_name ( str ) – 主机名或 IP 地址。存储服务器在其上运行。
    port ( int ) – 存储服务器在这个端口上侦听传入请求。
    world_size ( int , optional ) – 用户总数。
        world_size = 客户端数 + 1，1 代表服务器。
        默认值为 -1（负值表示不固定的用户数）。
    is_master ( bool , optional ) – 初始化存储服务器时为真，初始化存储客户端时为假。默认值为假。
    timeout ( timedelta , optional ) – store在初始化期间，以及get()和 wait()方法使用的超时时间。默认为 timedelta(seconds=300)。
    wait_for_worker ( bool , optional ) – 是否等待所有worker与存储服务器连接。这仅在 world_size 为固定值时适用。默认值为真。

使用例子如下：

    import torch.distributed as dist
    from datetime import timedelta
    # Run on process 1 (server)
    server_store = dist.TCPStore("127.0.0.1", 1234, 2, True, timedelta(seconds=30))
    # Run on process 2 (client)
    client_store = dist.TCPStore("127.0.0.1", 1234, 2, False)
    # Use any of the store methods from either the client or server after initialization
    server_store.set("first_key", "first_value")
    client_store.get("first_key")
或者
    >>> import torch.distributed as dist
    >>> from datetime import timedelta
    >>> # Using TCPStore as an example, other store types can also be used
    >>> store = dist.TCPStore("127.0.0.1", 0, 1, True, timedelta(seconds=30))
    >>> # This will throw an exception after 10 seconds
    >>> store.wait(["bad_key"], timedelta(seconds=10))
从例子上看，就是简单的 server，client 或者说 master, worker 的关系，我们接下来仔细分析。


4.2.2 socket用处
其成员变量之中最主要的是三个socket，或者说他们是 store 的精华（难点）所在。

      int storeSocket_ = -1; //
      int listenSocket_ = -1; //
      int masterListenSocket_ = -1; // master 在这里监听

4.2.2.1 业务分工
具体解释如下（后面还会结合代码继续分析）：

    masterListenSocket_ 是 listen 在 masterPort 之上。

        tcpStoreMasterDaemon_本身是一个master，就是为整个 TCPStore提供服务的 server。

        tcpStoreMasterDaemon_ 使用 tcputil::addPollfd(fds, storeListenSocket_, POLLIN) 来监听 masterListenSocket_。

        key-value 就是std::unordered_map<std::string, std::vector<uint8_t>> tcpStore。

    storeSocket_ 在 tcpStoreWorkerDaemon_ 之上，其连接到 masterListenSocket_ : masterPort 之上。

        storeSocket_ 的作用是封装面对 master port 的操作，用户只管 set，get 等操作，不用知道 master port。

        set(key, data) 的作用就是通过 storeSocket_ 向master 发送一个设置key : value 的请求。

        tcpStoreMasterDaemon_ 监听到socket变化，就开始相应。

        tcpStoreMasterDaemon_ 内部把 key : value 添加到 std::unordered_map<std::string, std::vector<uint8_t>> tcpStore_ 之上。

    listenSocket_ 在 tcpStoreWorkerDaemon_ 之上，也连接到 masterListenSocket_: masterPort 之上。
    下面有一个解耦，如注释所述，
    It will register the socket on TCPStoreMasterDaemon and the callback on TCPStoreWorkerDaemon。

            listenSocket_ 封装了对 watchKey 的处理。
            Store Client 使用watchKey(const std::string& key, WatchKeyCallback callback) 请求注册，即：

                Worker 请求注册。
                使用 tcpStoreWorkerDaemon_->setCallback(regKey, callback) 来为 tcpStoreWorkerDaemon_ 的
                std::unordered_map<std::string, WatchKeyCallback> keyToCallbacks_ 之上添加一个 callback。

                Worker 发送请求。
                通过 listenSocket_ 给 master 发消息 (key, WATCH_KEY)，告诉master，
                如果 key 的 value 有变化，就调用这个 callback。

            Master 执行注册。
            Master 接到 WATCH_KEY 消息之后进行注册，调用 watchHandler，使用 watchedSockets_[key].push_back(socket) 来配置，
            告诉自己，如果这个 key 有变化，就给这个 socket 发消息。

            Master通知Worker。
            在 TCPStoreMasterDaemon::setHandler 之中，如果设置了新 value 之后，
            调用 sendKeyUpdatesToClients，其会遍历 watchedSockets_[key]，如果有 socket，就给 socket 发送消息变化通知。

            Worker执行callback。
            所以如果 key 有变化，就在 tcpStoreWorkerDaemon_ 之中调用了这个 callback。

4.2.2.2 Set 例子
我们首先看看 Set 的例子如下，就是 Worker 通过 socket 来在 Master 之上设置 value。

                                                                          +
+----------------------------------------------------------------------+  |  +----------------------------------------------+
| TCPStore                                                      Master |  |  | TCPStore                              Worker |
|                                                                      |  |  |                                              |
|                                                                      |  |  |                                              |
|                                                                      |  |  |                                              |
|   +------------------------------------------------------------+     |  |  |                                              |
|   | TcpStoreMasterDaemon_                            MasterPort|     |  |  |                                              |
|   |                                                            |     |  |  |                                              |
|   |    TCPStore.masterListenSocket_                            |     |  |  |      +---------------------------------+     |
|   |                                                            |     |  |  |      | set(key, value)                 |     |
|   |                                                            |     |  |  |      |                                 |     |
|   |    tcpStore_[key] = value  <------------------------------------------------+ |    storeSocket_                 |     |
|   |                                                            |     |  |  |      |                                 |     |
|   |                                                            |     |  |  |      +---------------------------------+     |
|   |                                                            |     |  |  |                                              |
|   +------------------------------------------------------------+     |  |  |                                              |
|                                                                      |  |  |                                              |
+----------------------------------------------------------------------+  |  +----------------------------------------------+
                                                                          +
手机如下：  03-23.png

4.2.2.3 Set 和 watchKey 结合
Set 和 watchKey 结合起来的示意图如下（worker请求注册，具体执行回调；master执行注册，通知worker执行回调）：
    1 Worker 请求注册。
    Store Client 使用watchKey(const std::string& key, WatchKeyCallback callback) 就是使用
     tcpStoreWorkerDaemon_->setCallback(regKey, callback) 来为 tcpStoreWorkerDaemon_ 的
     std::unordered_map<std::string, WatchKeyCallback> keyToCallbacks_ 之上添加一个callback。

    2 Worker 发送请求。Worker 通过 listenSocket_ 给 master 发消息 (key, WATCH_KEY)，告诉master，
    如果 key 的 value 有变化，就调用这个 callback。

    3 Master 执行注册。Master 接到 WATCH_KEY 消息之后，
    调用 watchHandler，使用 watchedSockets_[key].push_back(socket) 来配置，
    告诉自己，如果这个 key 有变化，就给这个 socket 发消息。

    4 下面我们假设 Store Client（这里假设是同一个worker设置，实际上可能是不同worker）设置了一个 value。

    5 Master通知Worker。Master 在 TCPStoreMasterDaemon::setHandler 之中，如果设置了新 value 之后，
    调用 sendKeyUpdatesToClients，其会遍历 watchedSockets_[key]，
    如果有 socket，就给 socket 发送消息变化通知。

    6 Worker执行callback。
    如果 key 有变化，就在 tcpStoreWorkerDaemon_ 之中调用了这个 callback。

+----------------------------------------------------------------------+  +  +------------------------------------------------------------------------+
| TCPStore                                                      Master |  |  | TCPStore                                                        Worker |
|                                                                      |  |  |                                                                        |
|   +------------------------------------------------------------+     |  |  |                                                                        |
|   | TcpStoreMasterDaemon_                            MasterPort|     |  |  |      +---------------------------------+                               |
|   |                                                            |     |  |  |      |                                 |                               |
|   |                                                  2         |     |  |  |      | watchKey(key, callback) +----------------------+                |
|   |           TCPStore.masterListenSocket_   <----------------------------------+ |                                 |              |                |
|   |                       +                                    |     |  |  |      |    listenSocket_                |              |                |
|   |                       | 3                                  |     |  |  |      |                                 |            1 |                |
|   |                       v                                    |     |  |  |      |                                 |              |                |
|   |           watchedSockets_[key] = socket                    |     |  |  |      +---------------------------------+              |                |
|   |                                                            |     |  |  |                                                       |                |
|   |  +-------------------------------------------------+       |     |  |  |                                                       |                |
|   |  |                                                 |       |     |  |  |                                                       |                |
|   |  |    setHandler                                   |       |     |  |  |   +----------------------------------------------------------------+   |
|   |  |                                                 |       |     |  |  |   | TCPStoreWorkerDaemon                              |            |   |
|   |  |                                                 |       |     |  |  |   |                                                   v            |   |
|   |  |       tcpStore_[key] = newData                  |       |     |  |  |   |   unordered_map<string, WatchKeyCallback> keyToCallbacks_      |   |
|   |  |                   +                             |       |     |  |  |   |                                                                |   |
|   |  |                   |                             |       |     |  |  |   |   TCPStore.listenSocket_                                       |   |
|   |  |                   |                             |       |     |  |  |   |                                                                |   |
|   |  |                   v                             |       |     |  |  |   |  +----------------------------------------------------------+  |   |
|   |  |       sendKeyUpdatesToClients                   |       |     |  |  |   |  | run                                                      |  |   |
|   |  |                   +                             |       |  5  |  |  |   |  |                                                          |  |   |
|   |  |                   |                             |  +---------------------->+                                        6                 |  |   |
|   |  |                   |                             |  |    |     |  |  |   |  |       callbackHandler +-----> keyToCallbacks_(callback)  |  |   |
|   |  |                   v                             |  |    |     |  |  |   |  |                                                          |  |   |
|   |  |                                                 |  |    |     |  |  |   |  +----------------------------------------------------------+  |   |
|   |  |    for (int socket : watchedSockets_[key]){     |  |    |     |  |  |   +----------------------------------------------------------------+   |
|   |  |       tcputil::sendString(socket, key, true) +-----+    |     |  |  |                                                                        |
|   |  |    }                                            |       |     |  |  |                                                                        |
|   |  |                                                 |       |     |  |  |       +------------------------+                                       |
|   |  |                                                 |       |  4  |  |  |       | set(key, newData)      |                                       |
|   |  |                                                 | <-----------------------+ |                        |                                       |
|   |  +-------------------------------------------------+       |     |  |  |       |                        |                                       |
|   |                                                            |     |  |  |       +------------------------+                                       |
|   +------------------------------------------------------------+     |  |  |                                                                        |
|                                                                      |  |  |                                                                        |
+----------------------------------------------------------------------+  +  +------------------------------------------------------------------------+

手机如下：  03-24.png


4.2.7 总结
我们总结图例如下：

Master 之中使用MasterPort 进行监听请求。
关于存取value。
Worker 之中，storeSocket_ 被用来存储/获取value，对应下图 数字 1。
在 Master 之中对应了 tcpStore_。
关于监控。
Worker 之中，listenSocket_ 被用来通知 Master 我需要监听这个 key，对应下图 数字 2。同时 worker 内部给这个 key 设置了 callback，对应了下图 数字 3。
监听在 Master 之中对应了 watchedSockets_[key] = socket_ 。
Master 之中，如果设置 value 时候，发现是一个被监控的 key，就通知 watchedSockets_[key]，对应了下图 数字 4。
Worker 之中会进行相关业务调用。
                                                                          +
+----------------------------------------------------------------------+  |  +------------------------------------------------------------------------+
| TCPStore                                                      Master |  |  | TCPStore                                                        Worker |
|                                                                      |  |  |                                                                        |
|   storeSocket_                                                       |  |  |                                                                        |
|                                                                      |  |  |                                                                        |
|   +------------------------------------------------------------+     |  |  |                                                                        |
|   | TcpStoreMasterDaemon_                            MasterPort|     |  |  |  1   +---------------------------------+                               |
|   |                                                            | <--------------+ | set(key, value)                 |                               |
|   |   unordered_map<string, vector<uint8_t> > tcpStore_+---+   |     |  |  |      |                                 |                               |
|   |                                                        |   |     |  |  |      |    storeSocket_                 |                               |
|   |   TCPStore.masterListenSocket_                         |   |     |  |  |      |                                 |                               |
|   |                                                        |   |     |  |  |      +---------------------------------+                               |
|   |   +-----------------------------------------------+    |   |     |  |  |                                                                        |
|   |   |  run                                          |    |   |     |  |  |  2   +---------------------------------+                               |
|   |   |                                               |    |   | <--------------+ |                                 |                               |
|   |   |    queryFds     query                         |    |   |     |  |  |      | watchKey(key, callback) +-------------------------------+       |
|   |   |                                               |    |   |     |  |  |      |                                 |        3              |       |
|   |   |    setHandler   getHandler                    |    |   |     |  |  |      |    listenSocket_                |                       |       |
|   |   |                                               |    |   |     |  |  |      |                                 |                       |       |
|   |   +-----------------------------------------------+    |   |     |  |  |      |                                 |                       |       |
|   |                                                        |   |     |  |  |      +---------------------------------+                       |       |
|   +------------------------------------------------------------+     |  |  |                                                                |       |
|                                                            |         |  |  |                                                                |       |
|                                                            |         |  |  |                                                                |       |
|                                                            |         |  |  |   +----------------------------------------------------------------+   |
|                                                            |         |  |  |   | TCPStoreWorkerDaemon                                       |   |   |
|                                                            |         |  |  |   |                                                            |   |   |
|                                                            |         |  |  |   |   unordered_map<string, WatchKeyCallback> keyToCallbacks_  |   |   |
|                                                            |         |  |  |   |                                                            |   |   |
|                                                            |         |  |  |   |   TCPStore.listenSocket_                              +----+   |   |
|                                                            |         |  |  |   |                                                       |        |   |
|                                                            |         |  |  |   |  +----------------------------------------------------------+  |   |
|                                                            |         |  |  |   |  | run                                                |     |  |   |
|                                                            |     4   |  |  |   |  |                                                    |     |  |   |
|                                                            +--------------------->+                                                    v     |  |   |
|                                                                      |  |  |   |  |       callbackHandler +-----> keyToCallbacks_(callback)  |  |   |
|                                                                      |  |  |   |  |                                                          |  |   |
|                                                                      |  |  |   |  +----------------------------------------------------------+  |   |
|                                                                      |  |  |   +----------------------------------------------------------------+   |
+----------------------------------------------------------------------+  +  +------------------------------------------------------------------------+

手机如下： 03-25.png


至此，我们梳理了初始化方法和Store这两个概念，最终其实是Store这个概念在初始化过程中起了作用。
我们也通过TCPStore 的分析知道了一个Store应该具备的功能，比如设置KV，监控某个key的变等等，
正是这些功能才可以让若干进程彼此知道对方的存在。

下一篇我们介绍进程组的概念，敬请期待。