PyTorch 分布式之弹性训练(3)---代理
https://www.cnblogs.com/rossiXYZ/p/15728861.html

目录
[源码解析] PyTorch 分布式之弹性训练(3)---代理
0x00 摘要
0x01 总体背景
1.1 功能分离
1.2 Rendezvous
0x02 Agent 总体逻辑
2.1 功能
2.2 工作基础
2.3 部署
2.4 基类
0x03 Worker
3.1 Worker 定义
3.2 WorkerGroup
3.3 WorkerState
0x04 SimpleElasticAgent
4.1 总体运行
4.2 初始化workers
4.2.1 _rendezvous
4.2.2.1 处理成员关系变化
4.2.3.2 为 worker 分配 ranks
4.2.4 启动 workers 进程
4.3 ranks相关
4.3.1 _RoleInstanceInfo
4.3.2 _share_and_gather
4.3.3 _get_ranks
4.4 Worker 相关
4.4.1 重启
4.4.2 barrier
0x05 LocalElasticAgent
5.1 使用
5.2 停止
5.3 初始化
5.4 启动 worker 进程
5.5 监控
0xFF 参考
0x00 摘要
在前面的文章之中，我们已经学习了PyTorch 分布式的基本模块，介绍了官方的几个例子，我们接下来会介绍PyTorch的弹性训练，
本文是第三篇，看看弹性代理的基本功能。

弹性训练系列文章如下：

[源码解析] PyTorch 分布式之弹性训练(1) --- 总体思路

[源码解析] PyTorch 分布式之弹性训练(2)---启动&单节点流程

0x01 总体背景
我们先总述一下，TE 最重要的是 Agent 和 Rendezvous 这两个概念。

    Agent是运行在单节点上的独立后台进程，可以认为是 worker manager 或者 process supervisor，
    其负责启动worker，监控 worker 运行，捕获woker异常，通过 rendezvous 实现 worker 间的相互发现，
    当有成员变动时候负责基于 rendezvous 进行变更同步。

    为了实现弹性训练，需要有一个节点/进程之间彼此发现的机制。
    rendezvous就是这个发现机制或者说同步组件。
    当系统启动或者成员变更时候，所有worker会（重新）集合（rendezvous）以建立一个新的进程组。

1.1 功能分离
TE 是围绕在 Rendezvous 基础之上的多个elastic agent构成，这是一种功能分离，让我们对比一下看看。

    Agent 偏重具体节点上的逻辑。

        Agent 负责具体业务逻辑相关操作，比如启动进程执行用户程序，监控用户程序运行情况，如果有异常就通知 Rendezvous。

        Agent 是一个 worker manager，负责启动/管理 workers 进程，
        组成一个 worker group，监控 workers 运行状态，捕获失效 workers，如果有故障/新加入worker，则重启 worker group。

        Agent负责维护 WORLD_SIZE 以及 RANK 信息。用户不需要再手动提供，Agent会自动处理这些。

        Agent 是具体节点上的后台进程，是独立个体。Agent自己无法实现整体上的弹性训练，
        所以需要一个机制来完成 worker 之间的相互发现，变更同步等等（WORLD_SIZE 和 RANK 这些信息其实也需要多个节点同步才能确定），
        这就是下面的 Rendezvous 概念。

    Rendezvous 负责集群逻辑，保证节点之间对于""有哪些节点参与训练"达成强一致共识。

        每一个 Agent 内部包括一个 Rendezvous handler，
        这些 handler 总体上构成了一个 Rendezvous 集群，从而构成了一个 Agent 集群。

        Rendezvous 完成之后，会创建一个共享键值存储（shared key-value store），这个store实现了一个torch.distributed.Store API。
        此存储仅由已完成Rendezvous的成员共享，它旨在让Torch Distributed Elastic在初始化作业过程之中交换控制和数据信息。

        Rendezvous 负责在每个agent之上维护当前 group 所有相关信息。
        每个 agent 之上有一个 rendezvous，它们会互相通信，总体维护一套信息，这些信息存储在上面提到的Store 之中。

        Rendezvous 负责集群逻辑相关，比如新加入节点，移除节点，分配rank等等。

我们首先从源码中取出示意图看看，大家先有一个总体概念。
05-08.jpg


1.2 Rendezvous
我们本文只是简单介绍一下 rendezvous，重点在于介绍 agent。

在 Torch Distributed Elastic 上下文之中，我们使用 rendezvous 这个术语来特指一个特定功能：
一个结合了对等发现（peer discovery）的分布式同步（distributed synchronization）原语。

Rendezvous 被Torch Distributed Elastic用来收集一个训练job的参与者（节点），
这样，参与者们可以商议得到参与者列表和每个参与者的角色，也可以对训练何时开始/恢复做出一致的集体决定。

Rendezvous 把功能分割解耦，业务逻辑被抽象成为一系列算子，
比如 _RendevzousJoinOp。而 Rendezvous 内部维护了一套状态机，由算子决定下一步操作。
比如 _RendezvousOpExecutor 来执行各种算子，依据算子结果得到下一步应该执行的 Action，从而对本身进行操作。

比如在 _DistributedRendezvousOpExecutor 之中，如果发现了当前 action 是 ADD_TO_WAIT_LIST，
会执行 _add_to_wait_list，进而调用 self._state.wait_list.add(self._node)

    ,,,
        self._add_to_participants()
    elif action == _Action.ADD_TO_WAIT_LIST: # 发现当前Action
        self._add_to_wait_list() # 然后执行
    elif action == _Action.REMOVE_FROM_PARTICIPANTS:
    ...

0x02 Agent 总体逻辑
2.1 功能
Elastic agent 是 torchelastic 的控制台（control plane），他是一个独立进程，负责启动和管理底层 worker 进程，代理具体负责：

    与PyTorch原生分布式协同工作：使每个worker都能获得所有需要的信息，以便成功调用 torch.distributed.init_process_group()。

    容错：监控每个worker，当出现错误或者异常时能及时终止所有worker并重启它们。

    弹性：对成员更改作出反应，并使用新的成员来重启所有workers。

下图来自知乎，算是对上一个图的细化。
05-09.jpg


2.2 工作基础
Torchelast agent 和 用户worker 依据故障切换契约来工作：

    TE（torchelastic）希望用户worker以5分钟为误差完成工作。
    设计DDP应用程序时，最好让所有worker都失败，而不只是一个worker失败。
    TE不会在代理之间同步重启次数。
    TE re-rendezvous不会减少重启次数。
    当单个代理完成其工作（成功或失败）时，它将关闭rendezvous。如果其他代理仍有worker在工作，他们将被终止。
    基于上述情况，如果至少有一个代理完成了任务，则缩容（scale down）不起作用。
    当代理检测到Scale up时，它不会减少 "max_restarts"。
    Torchelast agent 之间通过etcd或者类似后端来保持协同工作。

2.3 部署
简单的agent部署在每个节点上，并与本地进程协同工作。更高级的agent可以远程启动和管理workers。
Agent可以做到彻底的去中心化，与其他agents（管理同一个job的workers）进行沟通协调做出一个集体性决策，决策是基于其管理的 workers 情况来完成。

对于如何配置，源码中也给出了示例，如果在GPU上启动训练一个拥有 8 个 trainer（每GPU一个trainer）的 job，我们可以做如下配置。

    1. Use 8 x single GPU instances, place an agent per instance, managing 1 worker per agent.
    2. Use 4 x double GPU instances, place an agent per instance, managing 2 workers per agent.
    3. Use 2 x quad GPU instances, place an agent per instance, managing 4 workers per agent.
    4. Use 1 x 8 GPU instance, place an agent per instance, managing 8 workers per agent.

2.4 基类
基类ElasticAgent 是一个 Abstract Class，真正运行的代理都需要由此派生。
从 ElasticAgent 的注释可知，代理进程负责管理一个或多个worker 进程。工作进程被假定为常规分布式PyTorch脚本。
当worker进程由代理创建时，代理将为worker进程提供必要的信息，以便正确初始化torch进程组。
部署时，精确的拓扑和 agent-to-worker 比率取决于代理的具体实现和用户作业放置偏好。

    class ElasticAgent(abc.ABC):
    ...

ElasticAgent 有两个派生类：

    SimpleElasticAgent 实现了基类的部分函数，其目的是为了方便扩展新代理的实现。

    LocalElasticAgent 派生了SimpleElasticAgent ，是目前弹性训练最终使用的代理，
    主要用于在本地进行操作，负责管理单机上所有的worker进程。

0x03 Worker
我们首先要看看 worker，这是 Agent 所管理的主体。

3.1 Worker 定义
Worker 类代表了一个worker实例，我们上文介绍了WorkerSpec，Worker 就是依据 WorkerSpec 构建出来的，其重点成员变量如下：

    id（任意）：唯一标识一个worker，具体是由ElasticAgent的特定实现来解释，
                对于本地代理，它可以是worker的pid（int），
                对于远程代理，它可以被编码为``host:port（string）`。

    local_rank ：worker的local rank。

    global_rank：worker的global rank。

    role_rank：具有相同角色的所有worker的rank。

    world_size：全局worker数量。

    role_world_size：具有相同角色的worker数量。

class Worker:
    """
...

3.2 WorkerGroup
WorkerGroup 代表了一个工作组，作为一个整体来管理多个 workers，进行批量处理。

class WorkerGroup:
    """

在SimpleElasticAgent 初始化之中，会建立一个 WorkerGroup。

class SimpleElasticAgent(ElasticAgent):
    """

3.3 WorkerState
WorkerState 表示 WorkerGroup的状态。工作组中的所有工作人员作为一个整体来维护/更改状态。
如果工作组中的一个worker失败，则整个工作组被认为是失败：

      UNKNOWN - agent lost track of worker group state, unrecoverable
      INIT - worker group object created not yet started
      HEALTHY - workers running and healthy
      UNHEALTHY - workers running and unhealthy
      STOPPED - workers stopped (interruped) by the agent
      SUCCEEDED - workers finished running (exit 0)
      FAILED - workers failed to successfully finish (exit !0)

具体这些状态意义如下：

UNKNOWN-代理丢失了对工作组状态的跟踪，无法恢复

INIT-创建的工作组对象尚未启动

HEALTHY-worker健康运行

UNHEALTHY-worker在运行但是不健康

STOPPED-代理停止（中断）worker

SUCCEEDED-worker已完成运行（exit数值为0）

FAILED-worker未能成功完成（exit数值不等于0)

工作组从初始的INIT状态开始，然后进入"健康"或"不健康"状态，最后到达终端"成功"或"失败"状态。
工作组可以被代理打断并且临时置于"停止"状态。
处于"已停止"状态的工作进程可以在不久的将来被调度重启，被设置为已停止的状态的例子为：

    观察到工作组故障|不健康

    检测到成员更改

当工作组上的操作（启动、停止、rdzv、重试等）失败，并导致操作部分应用于工作组时，状态将为"未知"。
这通常发生在状态改变期间发生异常，而且异常未捕获/未处理的情况下。
当工作组处于"未知"状态，代理不会恢复工作组，因此最好终止作业，并且由job manager重试节点。

WorkerState 具体定义如下：

class WorkerState(str, Enum):
    """


0x04 SimpleElasticAgent
SimpleElasticAgent 是 Agent 的实现类之一。此抽象是为了方便扩展新的 agent 实现。从后面可知，目前内置的 LocalElasticAgent 负责管理单机上的所有 worker 进程，如果用户希望只用一个代理就管理多机上所有的 worker，而不仅仅是本机 worker，那么可以通过扩展 SimpleElasticAgent 来实现一个自定义 Agent。

class SimpleElasticAgent(ElasticAgent):
...

4.1 总体运行
SimpleElasticAgent 主循环 _invoke_run 是核心逻辑（这里默认代理和worker在同一个机器之上），其中做如下操作：

使用 self._initialize_workers(self._worker_group) 完成初始化工作，比如来启动 worker，为每个worker 分配 rank 等等。
然后进入 while True 循环，在循环之中通过 _monitor_workers 定期轮训用户程序运行情况，得到 worker 进程运行结果，然后依据情况进行不同处理。
如果程序正常结束，则返回。
如果程序出错，则重试，如果重试次数达到，结束workers。
如果节点成员关系有变化，比如scale up就会有新的节点在waiting，这时候就重启所有workers。
    def _invoke_run(self, role: str = DEFAULT_ROLE) -> RunResult:
...
上面只是大概讲了下这个总体流程，我们接下来对这个总体流程逐一分析。

4.2 初始化workers
代理主循环之中，首先使用 self._initialize_workers(self._worker_group) 来启动 worker。在 _initialize_workers之中：

    首先使用 self._rendezvous(worker_group) 进行节点之间的同步共识操作以及rank处理等等。

    其次调用 _start_workers 启动 workers。这里的 _start_workers 是虚函数，需要派生类实现。

    @prof
    def _initialize_workers(self, worker_group: WorkerGroup) -> None:
....

4.2.1 _rendezvous
我们首先看看_rendezvous，其做如下操作：

    调用 next_rendezvous() 来处理成员关系变化，其会返回 world size，store等。

    会把 store 配置到 workgroup 之中，后续worker 之间就可以通过这个kvstore进行沟通。

    调用 _assign_worker_ranks 会生成 worker，并且为 worker 建立 ranks，
    返回的 workers 都赋值在代理的 worker_group.workers 之中。

以上两点都是利用 rendezvous 的信息来进行处理，比如从 rendezvous 之中提取 ranks。

    @prof
    def _rendezvous(self, worker_group: WorkerGroup) -> None:
...

4.2.2.1 处理成员关系变化
Elastic 调用 rdzv_handler.next_rendezvous() 来处理成员关系变化，
目的是启动下一轮 rendezvous 操作（因为本worker已经启动，需要加入集群）。

注意，next_rendezvous 是 RendezvousHandler 的内部函数。这一函数调用会被阻塞，直到 worker 的数量达到了要求。
在 worker 被初始化，或者重启的时候，这一函数都会被调用。当函数返回时，不同的 worker group 会以返回中的 rank 作为唯一的标示。
其内部逻辑是：

    先使用_RendezvousExitOp让该node退出。
    然后再使用_RendezvousJoinOp把该node重新加入。
    最后启动心跳，返回world size，store等。
yknote torch/distributed/elastic/rendezvous/dynamic_rendezvous.py
        def next_rendezvous(self) -> Tuple[Store, int, int]:
    ...
            return store, rank, world_size # 返回的是 worker group 的rank

4.2.3.2 为 worker 分配 ranks
接着是调用 _assign_worker_ranks 为 worker 建立 ranks。分配 rank 算法如下：

    每个代理将其配置（group_rank, group_world_size , num_workers）写入公共存储。

    每个代理检索所有代理的配置，并使用角色和rank执行两级排序。

    确定全局rank：
    当前代理的global rank是 本代理 的 group_rank 在infos数组的偏移量（offset）。
    偏移量的计算方法是，排名低于group_rank的所有代理的local_world之和。workers 的等级为：[offset, offset+local_world_size]。

    确定role rank：使用第3点中的算法确定role rank，
    不同之处是：偏移量计算是从与当前角色相同且具有最小 group rank 的第一个代理开始。

    因为所有代理都使用同样算法，所以其计算出的 ranks 数组都是相同的。

然后生成 workers，把 worker 都赋值在 worker_group.workers 之中。

    @prof
    def _assign_worker_ranks(
        self, store, group_rank: int, group_world_size: int, spec: WorkerSpec
    ...

4.2.4 启动 workers 进程
调用 派生类的 _start_workers 来启动 worker 进程，因此基类这里没有实现，我们后续会看到派生类如何实现。

    @abc.abstractmethod
    def _start_workers(self, worker_group: WorkerGroup) -> Dict[int, Any]:
        r"""
        Starts ``worker_group.spec.local_world_size`` number of workers
        according to worker spec for the worker group .

        Returns a map of ``local_rank`` to worker ``id``.
        """
        raise NotImplementedError()
目前逻辑如下，具体是：

    调用 rdzv_handler.next_rendezvous 来与其他 Node 进行同步。

    rdzv_handler.next_rendezvous 返回 ranks 等信息给_assign_worker_ranks。

    _assign_worker_ranks会生成一些Workers，其中每个 Worker都被自动分配了 rank。
    这些 workers 被 Agent的worker_group.workers所指向。
+--------------------------------------------------+
| LocalElasticAgent                                |         _initialize_workers
|                                                  |                 +
|                                                  |                 |
|                                                  |                 |
|   +----------------------+                       |                 v
|   |WorkerGroup           |                       |         _rendezvous(worker_group)
|   |                      |                       |                 +
|   |     spec             |                       |                 |
|   |                      |                       |                 | 1
|   |     group_world_size |                       |                 v
|   |                      |                       |        rdzv_handler.next_rendezvous()
|   |     store            |                       |                 +
|   |                      |    +----------------+ |                 |
|   |     group_rank       |    | Worker0(rank 0)| |               2 | ranks
|   |                      |    | Worker1(rank 1)| |  Workers        v
|   |     workers  +----------> | ...            | | <----+ _assign_worker_ranks
|   |                      |    | Workern(rank n)| |    3
|   +----------------------+    +----------------+ |
|                                                  |
+--------------------------------------------------+
接下来会分别把 rank 相关和 worker 相关的函数都分别罗列出来，以便大家更好的理解。

4.3 ranks相关
前面的 _assign_worker_ranks 为 worker 建立 ranks，但是其内部有些细节我们还需要梳理一下。

4.3.1 _RoleInstanceInfo
这里要介绍一下 _RoleInstanceInfo 这个数据结构。代理使用该类与其他代理交换信息。
该信息用于确定本代理workers的rank。这些代理工作在异构环境下，不同代理也许有不同数量的workers。
其构建参数是：

    role (str) : 用户定义的role。
    rank (int) : 代理的rank。
    local_world_size (int) : 本地 workers 的数目。

class _RoleInstanceInfo:
    """
...

4.3.2 _share_and_gather
_share_and_gather 的作用是在各个代理之间同步，得到角色的总体信息。每个代理将其配置（group_rank, group_world_size , num_workers）写入公共存储。这里就是使用之前 Rendezvous 返回的 store 来进行信息共享。

    def _share_and_gather(
        self, store, group_rank: int, group_world_size: int, spec: WorkerSpec
...


4.3.3 _get_ranks
依据 role infos 来确定全局rank：当前代理的global rank是 本代理 的 group_rank 在infos数组的偏移量（offset）。偏移量的计算方法是，排名低于group_rank的所有代理的local_world之和。workers 的等级为：[offset, offset+local_world_size]。

def _get_ranks(
...

目前逻辑拓展如下：

    调用 rdzv_handler.next_rendezvous() 来和其他节点进行同步，获得信息。

    获得信息中的store（可以认为就是远端的KV存储），group_world_size，group_rank 传给 Agent。

    ranks 等信息传给 _assign_worker_ranks方法。

    _assign_worker_ranks 之中，调用 _share_and_gather 在各个代理之间同步，得到角色的总体信息。
    每个代理将其配置（group_rank, group_world_size , num_workers）写入公共KV存储。

    依据 role infos 来确定全局rank：当前代理的global rank是 本代理 的 group_rank 在infos数组的偏移量（offset）。
    偏移量的计算方法是，排名低于group_rank的所有代理的local_world之和。

    使用各种信息建立一系列的 Workers。

    Workers 被复制给 Agent 的 WorkerGroup 之中。
                                                              _initialize_workers
                                                                      +
                                                                      |
                                                                      |
                                                                      v
                                                              _rendezvous(worker_group)
                                                                      +
+----------------------------------------------+                      |
| LocalElasticAgent                            |                      | 1
|                                              |   2                  v
|                                         +--------------+  rdzv_handler.next_rendezvous()
| +--------------------+                  |    |                      +
| | WorkerGroup        |                  |    |                      |
| |                    |                  |    |                    3 | ranks
| |                    |                  |    |                      v
| |  spec              |                  |    |       +--------------+------------------+
| |                    |                  |    |       | _assign_worker_ranks            |
| |                    |                  |    |       |                                 |
| |  store   <----------------------------+    |       |                        4        |
| |                    |                  |    |       | role_infos = _share_and_gather( |
| |                    |                  |    |       |               +          store) |
| |  group_world_size<--------------------+    |       |               | 5               |
| |                    |                  |    |       |               |                 |
| |                    |                  |    |       |               v                 |
| |  group_rank <-------------------------+    |       |          _get_ranks(world...)   |
| |                    |                       |       |          _get_ranks(role...)    |
| |                    |   +----------------+  |       |               +                 |
| |  workers  +----------->+ Worker0(rank 0)|  |       |               |                 |
| |                    |   | Worker1(rank 1)|  |       |               | 6               |
| |                    |   | ...            |  |Workers|               v                 |
| |                    |   | Workern(rank n)+<------------+ new Worker(local_rank,       |
| +--------------------+   +----------------+  |    7  |               global_rank,      |
|                                              |       |               role_rank,        |
+----------------------------------------------+       |               world_size,       |
                                                       |               role_world_size)  |
                                                       |                                 |
                                                       +---------------------------------+
_rendezvous 操作之后，Worker 实例已经生成了，接下来就看看如何生成 Worker 进程。
但是因为这些方法在 SimpleElasticAgent 之中并没有实现，所以我们需要在其派生类 LocalElasticAgent 分析小节才能继续拓展我们的逻辑图。

4.4 Worker 相关
我们先看看 SimpleElasticAgent 剩余两个 worker 相关函数。

4.4.1 重启
_restart_workers 是重启 workers。

    ..
    def _restart_workers(self, worker_group: WorkerGroup) -> None:
    ...

4.4.2 barrier
实际上，几乎不可能保证DDP的所有 worker 都能保证同时结束，所以因此TE提供了一个finalization barrier，这个barrier的作用是对worker finalization 实施等待超时（5分钟）。

    def _exit_barrier(self):
...

0x05 LocalElasticAgent
LocalElasticAgent 是弹性训练最终使用的代理，主要用于在本地进行操作，负责管理单机上所有的worker进程，其派生了 SimpleElasticAgent。

此代理在每个主机之上部署，并配置为生成n个工作进程。当使用GPU时，n是主机上可用的GPU数量。
本地代理不会与部署在其他主机上的其他本地代理通信，即使worker可以在主机间通信。
Worker id被解释为本地进程。代理作为把本机所有工作进程作为一个整体启动和停止。

传递给worker的函数和参数必须与python multiprocessing兼容。
要将multiprocessing数据结构传递给worker，
用户可以在与指定的start_method相同的多处理multiprocessing中创建数据结构，并将其作为函数参数传递。

exit_barrier_timeout用来指定等待其他代理完成的时间量（以秒为单位）。
这起到了一个安全网的作用，可以处理worker在不同时间完成的情况，以防止代理将提前完成的worker视为scale-down事件。
强烈建议用户代码确保worker以同步方式终止，而不是依赖于exit_barrier_timeout。

SimpleElasticAgent 主要是提供给了初始化和总体运行方式，但是遗留了一些抽象函数没有被实现，
比如_start_workers，_stop_workers，_monitor_workers，_shutdown。LocalElasticAgent 就补齐了这些函数。

    class LocalElasticAgent(SimpleElasticAgent):
    ...
5.1 使用
我们先从其注释中提取代码，看看如何使用。以下是如何把function作为入口来启动。

    def trainer(args) -> str:
        return "do train"

    def main():
        start_method="spawn"
        shared_queue= multiprocessing.get_context(start_method).Queue()
        spec = WorkerSpec(
                    role="trainer",
                    local_world_size=nproc_per_process,
                    entrypoint=trainer,
                    args=("foobar",),
                    ...<OTHER_PARAMS...>)
        agent = LocalElasticAgent(spec, start_method)
        results = agent.run()

        if results.is_failed():
            print("trainer failed")
        else:
            print(f"rank 0 return value: {results.return_values[0]}")
            # prints -> rank 0 return value: do train
以下是如何把binary作为入口来启动。

    def main():
        spec = WorkerSpec(
                    role="trainer",
                    local_world_size=nproc_per_process,
                    entrypoint="/usr/local/bin/trainer",
                    args=("--trainer_args", "foobar"),
                    ...<OTHER_PARAMS...>)
        agent = LocalElasticAgent(spec)
        results = agent.run()

        if not results.is_failed():
            print("binary launches do not have return values")
_rendezvous 操作之后，Worker 实例已经生成了，接下来就看看如何生成 Worker 进程。

5.2 停止
以下函数会停止workers。

    @prof
    def _stop_workers(self, worker_group: WorkerGroup) -> None:
        self._shutdown()

    def _shutdown(self) -> None:
        if self._pcontext:
            self._pcontext.close()
5.3 初始化
我们接着前文来说，_rendezvous 操作之后，Worker 实例已经生成了，接下来就看看如何生成 Worker 进程。
之前因为这些方法在 SimpleElasticAgent 之中并没有实现，所以我们在本小结继续拓展我们的逻辑图。

我们先再看看初始化workers。在 _initialize_workers之中，首先使用 _rendezvous 建立 workers 实例，
其次调用 _start_workers 启动 workers。

    @prof
    def _initialize_workers(self, worker_group: WorkerGroup) -> None:
....
        # on the rdzv barrier, this way we ensure that nodes enter rdzv
        # at around the same time and reduce false positive rdzv timeout errors
        self._rendezvous(worker_group) # Worker实例已经生成了

        worker_ids = self._start_workers(worker_group) # 启动Worker进程
        for local_rank, w_id in worker_ids.items():
            worker = worker_group.workers[local_rank]
            worker.id = w_id # 得到进程ID

        worker_group.state = WorkerState.HEALTHY

5.4 启动 worker 进程
_start_workers 方法会调用 start_processes 来启动 worker 进程，默认_start_method 是 "spawn"。也就是启动了多个进程，
并行执行用户程序。同时这些进程的运行结果会被监控。
start_processes 参数之中，entrypoint和args 是用户命令和参数，entrypoint可以是函数或者字符串。

_start_workers 把 start_processes 方法启动多线程的结果保存在 _pcontext 之中，后续就用 _pcontext 来继续控制，
比如结束 worker 就是直接调用 _pcontext 的 close方法。

    @prof
    def _start_workers(self, worker_group: WorkerGroup) -> Dict[int, Any]:
。。。。
5.5 监控
运行之后，TE 会调用 _monitor_workers 对workers进行监控。
之前把启动多线程的结果保存在 _pcontext 之中，现在就用 _pcontext 对运行情况进行监控。
yknote  torch/distributed/elastic/agent/server/local_elastic_agent.py
    @prof
    def _monitor_workers(self, worker_group: WorkerGroup) -> RunResult:
。。。

因为启动和监控涉及到系统整体运行逻辑，需要和 rendezvous 一起才能更好理解，
所以我们把这部分的分析推迟，等到 Rendezvous 之后再来做整体分析。

目前总体逻辑如下：

    调用 rdzv_handler.next_rendezvous() 来和其他节点进行同步，获得信息。

    获得信息中的store（可以认为就是远端的KV存储），group_world_size，group_rank 传给 Agent。

    ranks 等信息传给 _assign_worker_ranks方法。

    _assign_worker_ranks 之中，调用 _share_and_gather 在各个代理之间同步，得到角色的总体信息。
    每个代理将其配置（group_rank, group_world_size , num_workers）写入公共KV存储。

    依据 role infos 来确定全局rank：当前代理的global rank是 本代理 的 group_rank 在infos数组的偏移量（offset）。
    偏移量的计算方法是，排名低于group_rank的所有代理的local_world之和。

    使用各种信息建立一系列的 Workers。

    Workers 被复制给 Agent 的 WorkerGroup 之中。

    使用 _start_workers 来启动 worker 进程。

    把 worker 进程 id 赋值给 Agent 的 worker.id 之中，这样以后就可以用 worker.id 来操作进程。

    使用 _monitor_workers 监控 worker 进程。

    使用 _exit_barrier 来等待 worker 进程结束。
                                                              _initialize_workers
                                                                      +
                                                                      |
                                                                      |
                                                                      v
                                                              _rendezvous(worker_group)
                                                                      +
+----------------------------------------------+                      |
| LocalElasticAgent                            |                      | 1
|                                              |   2                  v
|                                         +--------------+  rdzv_handler.next_rendezvous()
| +--------------------+                  |    |                      +
| | WorkerGroup        |                  |    |                      |
| |                    |                  |    |                    3 | ranks
| |                    |                  |    |                      v
| |  spec              |                  |    |       +--------------+------------------+
| |                    |                  |    |       | _assign_worker_ranks            |
| |                    |                  |    |       |                                 |
| |  store   <----------------------------+    |       |                        4        |
| |                    |                  |    |       | role_infos = _share_and_gather( |
| |                    |                  |    |       |               +          store) |
| |  group_world_size<--------------------+    |       |               | 5               |
| |                    |                  |    |       |               |                 |
| |                    |                  |    |       |               v                 |
| |  group_rank <-------------------------+    |       |          _get_ranks(world...)   |
| |                    |                       |       |          _get_ranks(role...)    |
| |                    |   +----------------+  |       |               +                 |
| |  workers  +----------->+ Worker0(rank 0)|  |       |               |                 |
| |                    |   | Worker1(rank 1)|  |       |               | 6               |
| |                    |   | ...            |  |Workers|               v                 |
| |                    |   | Workern(rank n)+<------------+ new Worker(local_rank,       |
| +--------------------+   +---------+------+  |    7  |               global_rank,      |
|                                    ^         |       |               role_rank,        |
|                                    |         |       |               world_size,       |
|                                    |         |       |               role_world_size)  |
+----------------------------------------------+       |                                 |
                                     |                 +---------------+-----------------+
                                     |                                 |
                                     |                                 | 8
                                     |              9                  v
                                     +-----------------------+   _start_workers
                                                                       +
                                                                       | 10
                                                                       |
                                                                       v
                                                       +---------------+--------------+
                                                       | state = _monitor_workers     |
                                                  +--> |                              +-->
                                                  |    +---------------+--------------+  |
                                                  |                    |                 |
                                                  <--------------------------------------+
                                                     LOOP  Every 30S   |
                                                                       | 11
                                                                       v
                                                                    _exit_barrier
手机如下：
05-10.png


0xFF 参考
TorchElastic - 弹性、容错的分布式训练